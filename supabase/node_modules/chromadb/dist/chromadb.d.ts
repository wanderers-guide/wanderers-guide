import * as openai from 'openai';
import * as cohere_ai from 'cohere-ai';

interface IEmbeddingFunction {
    generate(texts: string[]): Promise<number[][]>;
}

declare enum IncludeEnum {
    Documents = "documents",
    Embeddings = "embeddings",
    Metadatas = "metadatas",
    Distances = "distances"
}
type Number = number;
type Embedding = Array<Number>;
type Embeddings = Array<Embedding>;
type Metadata = Record<string, string | number | boolean>;
type Metadatas = Array<Metadata>;
type Document = string;
type Documents = Array<Document>;
type ID = string;
type IDs = ID[];
type PositiveInteger = number;
type LiteralValue = string | number | boolean;
type ListLiteralValue = LiteralValue[];
type LiteralNumber = number;
type LogicalOperator = "$and" | "$or";
type InclusionOperator = "$in" | "$nin";
type WhereOperator = "$gt" | "$gte" | "$lt" | "$lte" | "$ne" | "$eq";
type OperatorExpression = {
    [key in WhereOperator | InclusionOperator | LogicalOperator]?: LiteralValue | ListLiteralValue;
};
type BaseWhere = {
    [key: string]: LiteralValue | OperatorExpression;
};
type LogicalWhere = {
    [key in LogicalOperator]?: Where[];
};
type Where = BaseWhere | LogicalWhere;
type WhereDocumentOperator = "$contains" | LogicalOperator;
type WhereDocument = {
    [key in WhereDocumentOperator]?: LiteralValue | LiteralNumber | WhereDocument[];
};
type CollectionType = {
    name: string;
    id: string;
    metadata: Metadata | null;
};
type GetResponse = {
    ids: IDs;
    embeddings: null | Embeddings;
    documents: (null | Document)[];
    metadatas: (null | Metadata)[];
    error: null | string;
};
type QueryResponse = {
    ids: IDs[];
    embeddings: null | Embeddings[];
    documents: (null | Document)[][];
    metadatas: (null | Metadata)[][];
    distances: null | number[][];
};
type AddResponse = {
    error: string;
};
type CollectionMetadata = Record<string, unknown>;

/**
 * FastAPI
 *
 *
 * OpenAPI spec version: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator+.
 * https://github.com/karlvr/openapi-generator-plus
 * Do not edit the class manually.
 */
interface ConfigurationParameters {
    apiKey?: string | ((name: string) => string | null);
    username?: string;
    password?: string;
    authorization?: string | ((name: string, scopes?: string[]) => string | null);
    basePath?: string;
}
declare class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey?: string | ((name: string) => string | null);
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username?: string;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password?: string;
    /**
     * parameter for oauth2, openIdConnect or http security
     * @param name security name
     * @param scopes oauth2 scopes
     * @memberof Configuration
     */
    authorization?: string | ((name: string, scopes?: string[]) => string | null);
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath?: string;
    constructor(param?: ConfigurationParameters);
}

/**
 * FastAPI
 *
 *
 * OpenAPI spec version: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator+.
 * https://github.com/karlvr/openapi-generator-plus
 * Do not edit the class manually.
 */
declare const defaultFetch: typeof fetch;

/**
 *
 * @export
 * @type FetchAPI
 */
type FetchAPI = typeof defaultFetch;
/**
 *
 * @export
 * @class BaseAPI
 */
declare class BaseAPI {
    protected basePath: string;
    protected fetch: FetchAPI;
    protected configuration?: Configuration;
    constructor(configuration?: Configuration, basePath?: string, fetch?: FetchAPI);
}

/**
 * FastAPI
 *
 *
 * OpenAPI spec version: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator+.
 * https://github.com/karlvr/openapi-generator-plus
 * Do not edit the class manually.
 */
declare namespace Api {
    interface Add201Response {
    }
    interface AddEmbedding {
        embeddings?: Api.AddEmbedding.Embedding[];
        metadatas?: Api.AddEmbedding.Metadata[];
        documents?: string[];
        ids: string[];
    }
    /**
     * @export
     * @namespace AddEmbedding
     */
    namespace AddEmbedding {
        interface Embedding {
        }
        interface Metadata {
        }
    }
    interface ADelete200Response {
    }
    interface AGet200Response {
    }
    interface Count200Response {
    }
    interface CreateCollection {
        name: string;
        metadata?: Api.CreateCollection.Metadata;
        'get_or_create'?: boolean;
    }
    /**
     * @export
     * @namespace CreateCollection
     */
    namespace CreateCollection {
        interface Metadata {
        }
    }
    interface CreateCollection200Response {
    }
    interface DeleteCollection200Response {
    }
    interface DeleteEmbedding {
        ids?: string[];
        where?: Api.DeleteEmbedding.Where;
        'where_document'?: Api.DeleteEmbedding.WhereDocument;
    }
    /**
     * @export
     * @namespace DeleteEmbedding
     */
    namespace DeleteEmbedding {
        interface Where {
        }
        interface WhereDocument {
        }
    }
    interface GetCollection200Response {
    }
    interface GetEmbedding {
        ids?: string[];
        where?: Api.GetEmbedding.Where;
        'where_document'?: Api.GetEmbedding.WhereDocument;
        sort?: string;
        /**
         * @type {number}
         * @memberof GetEmbedding
         */
        limit?: number;
        /**
         * @type {number}
         * @memberof GetEmbedding
         */
        offset?: number;
        include?: (Api.GetEmbedding.Include.EnumValueEnum | Api.GetEmbedding.Include.EnumValueEnum2 | Api.GetEmbedding.Include.EnumValueEnum3 | Api.GetEmbedding.Include.EnumValueEnum4)[];
    }
    /**
     * @export
     * @namespace GetEmbedding
     */
    namespace GetEmbedding {
        interface Where {
        }
        interface WhereDocument {
        }
        type Include = Api.GetEmbedding.Include.EnumValueEnum | Api.GetEmbedding.Include.EnumValueEnum2 | Api.GetEmbedding.Include.EnumValueEnum3 | Api.GetEmbedding.Include.EnumValueEnum4;
        /**
         * @export
         * @namespace Include
         */
        namespace Include {
            enum EnumValueEnum {
                Documents = "documents"
            }
            enum EnumValueEnum2 {
                Embeddings = "embeddings"
            }
            enum EnumValueEnum3 {
                Metadatas = "metadatas"
            }
            enum EnumValueEnum4 {
                Distances = "distances"
            }
        }
    }
    interface GetNearestNeighbors200Response {
    }
    interface HTTPValidationError {
        detail?: Api.ValidationError[];
    }
    interface ListCollections200Response {
    }
    interface QueryEmbedding {
        where?: Api.QueryEmbedding.Where;
        'where_document'?: Api.QueryEmbedding.WhereDocument;
        'query_embeddings': Api.QueryEmbedding.QueryEmbedding2[];
        /**
         * @type {number}
         * @memberof QueryEmbedding
         */
        'n_results'?: number;
        include?: (Api.QueryEmbedding.Include.EnumValueEnum | Api.QueryEmbedding.Include.EnumValueEnum2 | Api.QueryEmbedding.Include.EnumValueEnum3 | Api.QueryEmbedding.Include.EnumValueEnum4)[];
    }
    /**
     * @export
     * @namespace QueryEmbedding
     */
    namespace QueryEmbedding {
        interface Where {
        }
        interface WhereDocument {
        }
        interface QueryEmbedding2 {
        }
        type Include = Api.QueryEmbedding.Include.EnumValueEnum | Api.QueryEmbedding.Include.EnumValueEnum2 | Api.QueryEmbedding.Include.EnumValueEnum3 | Api.QueryEmbedding.Include.EnumValueEnum4;
        /**
         * @export
         * @namespace Include
         */
        namespace Include {
            enum EnumValueEnum {
                Documents = "documents"
            }
            enum EnumValueEnum2 {
                Embeddings = "embeddings"
            }
            enum EnumValueEnum3 {
                Metadatas = "metadatas"
            }
            enum EnumValueEnum4 {
                Distances = "distances"
            }
        }
    }
    interface Update200Response {
    }
    interface UpdateCollection {
        'new_name'?: string;
        'new_metadata'?: Api.UpdateCollection.NewMetadata;
    }
    /**
     * @export
     * @namespace UpdateCollection
     */
    namespace UpdateCollection {
        interface NewMetadata {
        }
    }
    interface UpdateCollection200Response {
    }
    interface UpdateEmbedding {
        embeddings?: Api.UpdateEmbedding.Embedding[];
        metadatas?: Api.UpdateEmbedding.Metadata[];
        documents?: string[];
        ids: string[];
    }
    /**
     * @export
     * @namespace UpdateEmbedding
     */
    namespace UpdateEmbedding {
        interface Embedding {
        }
        interface Metadata {
        }
    }
    interface Upsert200Response {
    }
    interface ValidationError {
        loc: (string | number)[];
        msg: string;
        'type': string;
    }
}

/**
 * FastAPI
 *
 *
 * OpenAPI spec version: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator+.
 * https://github.com/karlvr/openapi-generator-plus
 * Do not edit the class manually.
 */

/**
 * ApiApi - object-oriented interface
 * @export
 * @class ApiApi
 * @extends {BaseAPI}
 */
declare class ApiApi extends BaseAPI {
    /**
     * @summary Add
     * @param {string} collectionId
     * @param {Api.AddEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    add(collectionId: string, request: Api.AddEmbedding, options?: RequestInit): Promise<Api.Add201Response>;
    /**
     * @summary Delete
     * @param {string} collectionId
     * @param {Api.DeleteEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    aDelete(collectionId: string, request: Api.DeleteEmbedding, options?: RequestInit): Promise<Api.ADelete200Response>;
    /**
     * @summary Get
     * @param {string} collectionId
     * @param {Api.GetEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    aGet(collectionId: string, request: Api.GetEmbedding, options?: RequestInit): Promise<Api.AGet200Response>;
    /**
     * @summary Count
     * @param {string} collectionId
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    count(collectionId: string, options?: RequestInit): Promise<Api.Count200Response>;
    /**
     * @summary Create Collection
     * @param {Api.CreateCollection} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollection(request: Api.CreateCollection, options?: RequestInit): Promise<Api.CreateCollection200Response>;
    /**
     * @summary Delete Collection
     * @param {string} collectionName
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCollection(collectionName: string, options?: RequestInit): Promise<Api.DeleteCollection200Response>;
    /**
     * @summary Get Collection
     * @param {string} collectionName
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollection(collectionName: string, options?: RequestInit): Promise<Api.GetCollection200Response>;
    /**
     * @summary Get Nearest Neighbors
     * @param {string} collectionId
     * @param {Api.QueryEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNearestNeighbors(collectionId: string, request: Api.QueryEmbedding, options?: RequestInit): Promise<Api.GetNearestNeighbors200Response>;
    /**
     * @summary Heartbeat
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    heartbeat(options?: RequestInit): Promise<{
        [name: string]: number;
    }>;
    /**
     * @summary List Collections
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollections(options?: RequestInit): Promise<Api.ListCollections200Response>;
    /**
     * @summary Reset
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    reset(options?: RequestInit): Promise<boolean>;
    /**
     * @summary Root
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    root(options?: RequestInit): Promise<{
        [name: string]: number;
    }>;
    /**
     * @summary Update
     * @param {string} collectionId
     * @param {Api.UpdateEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(collectionId: string, request: Api.UpdateEmbedding, options?: RequestInit): Promise<Api.Update200Response>;
    /**
     * @summary Update Collection
     * @param {string} collectionId
     * @param {Api.UpdateCollection} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCollection(collectionId: string, request: Api.UpdateCollection, options?: RequestInit): Promise<Api.UpdateCollection200Response>;
    /**
     * @summary Upsert
     * @param {string} collectionId
     * @param {Api.AddEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    upsert(collectionId: string, request: Api.AddEmbedding, options?: RequestInit): Promise<Api.Upsert200Response>;
    /**
     * @summary Version
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    version(options?: RequestInit): Promise<string>;
}

declare class Collection {
    name: string;
    id: string;
    metadata: CollectionMetadata | undefined;
    /**
     * @ignore
     */
    private api;
    /**
     * @ignore
     */
    embeddingFunction: IEmbeddingFunction | undefined;
    /**
     * @ignore
     */
    constructor(name: string, id: string, api: ApiApi, metadata?: CollectionMetadata, embeddingFunction?: IEmbeddingFunction);
    /**
     * @ignore
     */
    private setName;
    /**
     * @ignore
     */
    private setMetadata;
    /**
     * @ignore
     */
    private validate;
    /**
     * Add items to the collection
     * @param {Object} params - The parameters for the query.
     * @param {ID | IDs} [params.ids] - IDs of the items to add.
     * @param {Embedding | Embeddings} [params.embeddings] - Optional embeddings of the items to add.
     * @param {Metadata | Metadatas} [params.metadatas] - Optional metadata of the items to add.
     * @param {Document | Documents} [params.documents] - Optional documents of the items to add.
    * @returns {Promise<AddResponse>} - The response from the API. True if successful.
     *
     * @example
     * ```typescript
     * const response = await collection.add({
     *   ids: ["id1", "id2"],
     *   embeddings: [[1, 2, 3], [4, 5, 6]],
     *   metadatas: [{ "key": "value" }, { "key": "value" }],
     *   documents: ["document1", "document2"]
     * });
     * ```
     */
    add({ ids, embeddings, metadatas, documents, }: {
        ids: ID | IDs;
        embeddings?: Embedding | Embeddings;
        metadatas?: Metadata | Metadatas;
        documents?: Document | Documents;
    }): Promise<AddResponse>;
    /**
     * Upsert items to the collection
     * @param {Object} params - The parameters for the query.
     * @param {ID | IDs} [params.ids] - IDs of the items to add.
     * @param {Embedding | Embeddings} [params.embeddings] - Optional embeddings of the items to add.
     * @param {Metadata | Metadatas} [params.metadatas] - Optional metadata of the items to add.
     * @param {Document | Documents} [params.documents] - Optional documents of the items to add.
     * @returns {Promise<boolean>} - The response from the API. True if successful.
     *
     * @example
     * ```typescript
     * const response = await collection.upsert({
     *   ids: ["id1", "id2"],
     *   embeddings: [[1, 2, 3], [4, 5, 6]],
     *   metadatas: [{ "key": "value" }, { "key": "value" }],
     *   documents: ["document1", "document2"],
     * });
     * ```
     */
    upsert({ ids, embeddings, metadatas, documents, }: {
        ids: ID | IDs;
        embeddings?: Embedding | Embeddings;
        metadatas?: Metadata | Metadatas;
        documents?: Document | Documents;
    }): Promise<boolean>;
    /**
     * Count the number of items in the collection
     * @returns {Promise<number>} - The response from the API.
     *
     * @example
     * ```typescript
     * const response = await collection.count();
     * ```
     */
    count(): Promise<number>;
    /**
     * Modify the collection name or metadata
     * @param {Object} params - The parameters for the query.
     * @param {string} [params.name] - Optional new name for the collection.
     * @param {CollectionMetadata} [params.metadata] - Optional new metadata for the collection.
     * @returns {Promise<void>} - The response from the API.
     *
     * @example
     * ```typescript
     * const response = await collection.modify({
     *   name: "new name",
     *   metadata: { "key": "value" },
     * });
     * ```
     */
    modify({ name, metadata }?: {
        name?: string;
        metadata?: CollectionMetadata;
    }): Promise<void>;
    /**
     * Get items from the collection
     * @param {Object} params - The parameters for the query.
     * @param {ID | IDs} [params.ids] - Optional IDs of the items to get.
     * @param {Where} [params.where] - Optional where clause to filter items by.
     * @param {PositiveInteger} [params.limit] - Optional limit on the number of items to get.
     * @param {PositiveInteger} [params.offset] - Optional offset on the items to get.
     * @param {IncludeEnum[]} [params.include] - Optional list of items to include in the response.
     * @param {WhereDocument} [params.whereDocument] - Optional where clause to filter items by.
     * @returns {Promise<GetResponse>} - The response from the server.
     *
     * @example
     * ```typescript
     * const response = await collection.get({
     *   ids: ["id1", "id2"],
     *   where: { "key": "value" },
     *   limit: 10,
     *   offset: 0,
     *   include: ["embeddings", "metadatas", "documents"],
     *   whereDocument: { $contains: "value" },
     * });
     * ```
     */
    get({ ids, where, limit, offset, include, whereDocument, }?: {
        ids?: ID | IDs;
        where?: Where;
        limit?: PositiveInteger;
        offset?: PositiveInteger;
        include?: IncludeEnum[];
        whereDocument?: WhereDocument;
    }): Promise<GetResponse>;
    /**
     * Update the embeddings, documents, and/or metadatas of existing items
     * @param {Object} params - The parameters for the query.
     * @param {ID | IDs} [params.ids] - The IDs of the items to update.
     * @param {Embedding | Embeddings} [params.embeddings] - Optional embeddings to update.
     * @param {Metadata | Metadatas} [params.metadatas] - Optional metadatas to update.
     * @param {Document | Documents} [params.documents] - Optional documents to update.
     * @returns {Promise<boolean>} - The API Response. True if successful. Else, error.
     *
     * @example
     * ```typescript
     * const response = await collection.update({
     *   ids: ["id1", "id2"],
     *   embeddings: [[1, 2, 3], [4, 5, 6]],
     *   metadatas: [{ "key": "value" }, { "key": "value" }],
     *   documents: ["new document 1", "new document 2"],
     * });
     * ```
     */
    update({ ids, embeddings, metadatas, documents, }: {
        ids: ID | IDs;
        embeddings?: Embedding | Embeddings;
        metadatas?: Metadata | Metadatas;
        documents?: Document | Documents;
    }): Promise<boolean>;
    /**
     * Performs a query on the collection using the specified parameters.
     *
     * @param {Object} params - The parameters for the query.
     * @param {Embedding | Embeddings} [params.queryEmbeddings] - Optional query embeddings to use for the search.
     * @param {PositiveInteger} [params.nResults] - Optional number of results to return (default is 10).
     * @param {Where} [params.where] - Optional query condition to filter results based on metadata values.
     * @param {string | string[]} [params.queryTexts] - Optional query text(s) to search for in the collection.
     * @param {WhereDocument} [params.whereDocument] - Optional query condition to filter results based on document content.
     * @param {IncludeEnum[]} [params.include] - Optional array of fields to include in the result, such as "metadata" and "document".
     *
     * @returns {Promise<QueryResponse>} A promise that resolves to the query results.
     * @throws {Error} If there is an issue executing the query.
     * @example
     * // Query the collection using embeddings
     * const results = await collection.query({
     *   queryEmbeddings: [[0.1, 0.2, ...], ...],
     *   nResults: 10,
     *   where: {"name": {"$eq": "John Doe"}},
     *   include: ["metadata", "document"]
     * });
     * @example
     * ```js
     * // Query the collection using query text
     * const results = await collection.query({
     *   queryTexts: "some text",
     *   nResults: 10,
     *   where: {"name": {"$eq": "John Doe"}},
     *   include: ["metadata", "document"]
     * });
     * ```
     *
     */
    query({ queryEmbeddings, nResults, where, queryTexts, whereDocument, include, }: {
        queryEmbeddings?: Embedding | Embeddings;
        nResults?: PositiveInteger;
        where?: Where;
        queryTexts?: string | string[];
        whereDocument?: WhereDocument;
        include?: IncludeEnum[];
    }): Promise<QueryResponse>;
    /**
     * Peek inside the collection
     * @param {Object} params - The parameters for the query.
     * @param {PositiveInteger} [params.limit] - Optional number of results to return (default is 10).
     * @returns {Promise<GetResponse>} A promise that resolves to the query results.
     * @throws {Error} If there is an issue executing the query.
     *
     * @example
     * ```typescript
     * const results = await collection.peek({
     *   limit: 10
     * });
     * ```
     */
    peek({ limit }?: {
        limit?: PositiveInteger;
    }): Promise<GetResponse>;
    /**
     * Deletes items from the collection.
     * @param {Object} params - The parameters for deleting items from the collection.
     * @param {ID | IDs} [params.ids] - Optional ID or array of IDs of items to delete.
     * @param {Where} [params.where] - Optional query condition to filter items to delete based on metadata values.
     * @param {WhereDocument} [params.whereDocument] - Optional query condition to filter items to delete based on document content.
     * @returns {Promise<string[]>} A promise that resolves to the IDs of the deleted items.
     * @throws {Error} If there is an issue deleting items from the collection.
     *
     * @example
     * ```typescript
     * const results = await collection.delete({
     *   ids: "some_id",
     *   where: {"name": {"$eq": "John Doe"}},
     *   whereDocument: {"$contains":"search_string"}
     * });
     * ```
     */
    delete({ ids, where, whereDocument }?: {
        ids?: ID | IDs;
        where?: Where;
        whereDocument?: WhereDocument;
    }): Promise<string[]>;
}

interface ClientAuthProvider {
    /**
     * Abstract method for authenticating a client.
     */
    authenticate(): ClientAuthResponse;
}
interface ClientAuthConfigurationProvider<T> {
    /**
     * Abstract method for getting the configuration for the client.
     */
    getConfig(): T;
}
interface ClientAuthCredentialsProvider<T> {
    /**
     * Abstract method for getting the credentials for the client.
     * @param user
     */
    getCredentials(user?: string): T;
}
declare enum AuthInfoType {
    COOKIE = "cookie",
    HEADER = "header",
    URL = "url",
    METADATA = "metadata"
}
interface ClientAuthResponse {
    getAuthInfoType(): AuthInfoType;
    getAuthInfo(): {
        key: string;
        value: string;
    };
}
type AuthOptions = {
    provider: ClientAuthProvider | string | undefined;
    credentialsProvider?: ClientAuthCredentialsProvider<any> | undefined;
    configProvider?: ClientAuthConfigurationProvider<any> | undefined;
    credentials?: any | undefined;
    providerOptions?: any | undefined;
};

declare class ChromaClient {
    /**
     * @ignore
     */
    private api;
    private apiAdapter;
    /**
     * Creates a new ChromaClient instance.
     * @param {Object} params - The parameters for creating a new client
     * @param {string} [params.path] - The base path for the Chroma API.
     * @returns {ChromaClient} A new ChromaClient instance.
     *
     * @example
     * ```typescript
     * const client = new ChromaClient({
     *   path: "http://localhost:8000"
     * });
     * ```
     */
    constructor({ path, fetchOptions, auth, }?: {
        path?: string;
        fetchOptions?: RequestInit;
        auth?: AuthOptions;
    });
    /**
     * Resets the state of the object by making an API call to the reset endpoint.
     *
     * @returns {Promise<boolean>} A promise that resolves when the reset operation is complete.
     * @throws {Error} If there is an issue resetting the state.
     *
     * @example
     * ```typescript
     * await client.reset();
     * ```
     */
    reset(): Promise<boolean>;
    /**
     * Returns the version of the Chroma API.
     * @returns {Promise<string>} A promise that resolves to the version of the Chroma API.
     *
     * @example
     * ```typescript
     * const version = await client.version();
     * ```
     */
    version(): Promise<string>;
    /**
     * Returns a heartbeat from the Chroma API.
     * @returns {Promise<number>} A promise that resolves to the heartbeat from the Chroma API.
     *
     * @example
     * ```typescript
     * const heartbeat = await client.heartbeat();
     * ```
     */
    heartbeat(): Promise<number>;
    /**
     * Creates a new collection with the specified properties.
     *
     * @param {Object} params - The parameters for creating a new collection.
     * @param {string} params.name - The name of the collection.
     * @param {CollectionMetadata} [params.metadata] - Optional metadata associated with the collection.
     * @param {IEmbeddingFunction} [params.embeddingFunction] - Optional custom embedding function for the collection.
     *
     * @returns {Promise<Collection>} A promise that resolves to the created collection.
     * @throws {Error} If there is an issue creating the collection.
     *
     * @example
     * ```typescript
     * const collection = await client.createCollection({
     *   name: "my_collection",
     *   metadata: {
     *     "description": "My first collection"
     *   }
     * });
     * ```
     */
    createCollection({ name, metadata, embeddingFunction }: {
        name: string;
        metadata?: CollectionMetadata;
        embeddingFunction?: IEmbeddingFunction;
    }): Promise<Collection>;
    /**
     * Gets or creates a collection with the specified properties.
     *
     * @param {Object} params - The parameters for creating a new collection.
     * @param {string} params.name - The name of the collection.
     * @param {CollectionMetadata} [params.metadata] - Optional metadata associated with the collection.
     * @param {IEmbeddingFunction} [params.embeddingFunction] - Optional custom embedding function for the collection.
     *
     * @returns {Promise<Collection>} A promise that resolves to the got or created collection.
     * @throws {Error} If there is an issue getting or creating the collection.
     *
     * @example
     * ```typescript
     * const collection = await client.getOrCreateCollection({
     *   name: "my_collection",
     *   metadata: {
     *     "description": "My first collection"
     *   }
     * });
     * ```
     */
    getOrCreateCollection({ name, metadata, embeddingFunction }: {
        name: string;
        metadata?: CollectionMetadata;
        embeddingFunction?: IEmbeddingFunction;
    }): Promise<Collection>;
    /**
     * Lists all collections.
     *
     * @returns {Promise<CollectionType[]>} A promise that resolves to a list of collection names.
     * @throws {Error} If there is an issue listing the collections.
     *
     * @example
     * ```typescript
     * const collections = await client.listCollections();
     * ```
     */
    listCollections(): Promise<CollectionType[]>;
    /**
     * Gets a collection with the specified name.
     * @param {Object} params - The parameters for getting a collection.
     * @param {string} params.name - The name of the collection.
     * @param {IEmbeddingFunction} [params.embeddingFunction] - Optional custom embedding function for the collection.
     * @returns {Promise<Collection>} A promise that resolves to the collection.
     * @throws {Error} If there is an issue getting the collection.
     *
     * @example
     * ```typescript
     * const collection = await client.getCollection({
     *   name: "my_collection"
     * });
     * ```
     */
    getCollection({ name, embeddingFunction }: {
        name: string;
        embeddingFunction?: IEmbeddingFunction;
    }): Promise<Collection>;
    /**
     * Deletes a collection with the specified name.
     * @param {Object} params - The parameters for deleting a collection.
     * @param {string} params.name - The name of the collection.
     * @returns {Promise<void>} A promise that resolves when the collection is deleted.
     * @throws {Error} If there is an issue deleting the collection.
     *
     * @example
     * ```typescript
     * await client.deleteCollection({
     *  name: "my_collection"
     * });
     * ```
     */
    deleteCollection({ name }: {
        name: string;
    }): Promise<void>;
}

declare class OpenAIEmbeddingFunction implements IEmbeddingFunction {
    private api_key;
    private org_id;
    private model;
    private openaiApi?;
    constructor({ openai_api_key, openai_model, openai_organization_id }: {
        openai_api_key: string;
        openai_model?: string;
        openai_organization_id?: string;
    });
    private loadClient;
    generate(texts: string[]): Promise<number[][]>;
    /** @ignore */
    static import(): Promise<{
        openai: typeof openai;
        version: string;
    }>;
}

declare class CohereEmbeddingFunction implements IEmbeddingFunction {
    private api_key;
    private model;
    private cohereAiApi?;
    constructor({ cohere_api_key, model }: {
        cohere_api_key: string;
        model?: string;
    });
    private loadClient;
    generate(texts: string[]): Promise<any>;
    /** @ignore */
    static import(): Promise<{
        cohere: typeof cohere_ai;
    }>;
}

export { ChromaClient, CohereEmbeddingFunction, Collection, IEmbeddingFunction, IncludeEnum, OpenAIEmbeddingFunction };
